# Gravitas WASM Bridge (`gravitas-wasm`)

A high-performance WebAssembly binding for the **Gravitas** General Relativity engine, built specifically to power real-time black hole simulations and spacetime visualizations in the browser.

## Overview

While `gravitas-core` handles the rigorous tensor calculus and geodesic integration in pure Rust, `gravitas-wasm` exposes this functionality to JavaScript/TypeScript environments with near-native performance. It achieves this by bypassing standard slow JavaScript object serialization in favor of direct memory access and zero-copy data transfer.

## Key Features

- **Zero-Copy Memory Access:** Utilizes `SharedArrayBuffer` and direct WASM linear memory views (e.g., `Float64Array`, `Float32Array`) to stream massive amounts of geodesic trajectory data directly to the GPU without serialization overhead.
- **Spacetime Visualization Bindings:** Exposes highly complex spacetime geometry data generated by the core engine (Flamm's paraboloid matrices, frame-dragging flow vectors, Kerr metric tensor states, Kretschmann scalars) to be rendered by React Three Fiber / WebGL.
- **Real-Time Integrator State:** Manages the active state of thousands of photon geodesics simultaneously, updating their positions frame-by-frame for the compute shaders.
- **Full TypeScript Typed ABI:** Ensures end-to-end type safety between the TypeScript frontend and the Rust physics engine.

## Usage in JavaScript/TypeScript

This crate is typically compiled using `wasm-pack` and imported into standard frontend pipelines (like Next.js or Vite).

```typescript
import init, { SpacetimeViz, Universe } from "../public/wasm";

async function initPhysics() {
  // Initialize the WASM module
  await init();

  // Create a Universe instance with Mass = 1.0, Spin = 0.99
  const universe = Universe.new(1.0, 0.99);

  // Generate an Ergosphere mesh geometry (direct Float32Array pointers)
  const viz = SpacetimeViz.new(1.0, 0.99);
  const ergospherePtr = viz.get_ergosphere_vertices();

  // Create a 3D view into WASM memory
  // This data can be directly attached to a THREE.BufferGeometry
  const vertices = new Float32Array(
    wasm.memory.buffer,
    ergospherePtr,
    viz.ergosphere_vertex_count() * 3,
  );
}
```

## Architecture & Data Flow

1. **Frontend Input:** User changes parameters (Mass, Spin) via the React UI.
2. **WASM Call:** TypeScript calls `Universe::set_parameters(mass, spin)` on the WASM instance.
3. **Core Physics:** `gravitas-core` recalculates the Kerr metric, event horizon, ISCO, and resets the Hamiltonian integrators.
4. **Memory Sync:** The WASM bridge rewrites the internal contiguous arrays.
5. **Render Pass:** The frontend's WebGPU/WebGL shaders read the updated floating-point arrays directly from the WASM linear memory and draw the next frame.

## Interoperability Highlights

- **React Three Fiber:** Perfectly paired with `<primitive>` and `BufferGeometry` components to render the 3D metric fields, frame-dragging flow vectors, and light cones.
- **WebGPU Compute Shaders:** Provides the initial state vectors and metric parameters that the GPU compute passes use for massive parallel ray-marching.

## License

MIT
