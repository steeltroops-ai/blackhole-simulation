/**
 * Property-based tests for visual clarity
 * Tests disk color saturation, star brightness, tone mapping, and UI contrast
 */

import { describe, it, expect } from 'vitest';
import * as fc from 'fast-check';
import {
    rgbToHsl,
    hslToRgb,
    increaseSaturation,
    toneMapPreserveHue,
    getContrastRatio,
    meetsWCAGAA
} from '@/utils/color-utils';

describe('Visual Clarity - Property-Based Tests', () => {
    /**
     * Feature: blackhole-enhancement, Property 28: Disk color saturation
     * Validates: Requirements 9.2
     * 
     * For any accretion disk color generated by the temperature mapping,
     * the HSL saturation component should be above a minimum threshold (e.g., 0.5)
     * to ensure high saturation.
     */
    it('Property 28: Disk color saturation', () => {
        fc.assert(
            fc.property(
                fc.record({
                    r: fc.integer({ min: 0, max: 255 }),
                    g: fc.integer({ min: 0, max: 255 }),
                    b: fc.integer({ min: 0, max: 255 })
                }).filter(({ r, g, b }) => {
                    // Filter out pure black and pure white as they have undefined saturation
                    const max = Math.max(r, g, b);
                    const min = Math.min(r, g, b);
                    return max > 10 && (max - min) > 5;
                }),
                ({ r, g, b }) => {
                    // Simulate the saturation boost applied in the shader
                    const [h, s, l] = rgbToHsl(r, g, b);

                    // Apply saturation boost (minimum 0.6 as in shader)
                    const targetSaturation = Math.max(s, 0.6);

                    // Verify that the target saturation meets the minimum threshold
                    expect(targetSaturation).toBeGreaterThanOrEqual(0.5);

                    // Verify that boosting saturation produces a valid color
                    const boostedColor = increaseSaturation(r, g, b, 0.3);
                    expect(boostedColor[0]).toBeGreaterThanOrEqual(0);
                    expect(boostedColor[0]).toBeLessThanOrEqual(255);
                    expect(boostedColor[1]).toBeGreaterThanOrEqual(0);
                    expect(boostedColor[1]).toBeLessThanOrEqual(255);
                    expect(boostedColor[2]).toBeGreaterThanOrEqual(0);
                    expect(boostedColor[2]).toBeLessThanOrEqual(255);
                }
            ),
            { numRuns: 100 }
        );
    });

    /**
     * Feature: blackhole-enhancement, Property 29: Star brightness contrast
     * Validates: Requirements 9.3
     * 
     * For any background star, the brightness value should be above a minimum
     * threshold to ensure visibility against the black background.
     */
    it('Property 29: Star brightness contrast', () => {
        fc.assert(
            fc.property(
                fc.float({ min: Math.fround(0), max: Math.fround(1) }).filter(x => !isNaN(x) && isFinite(x)),
                (starBrightness) => {
                    // Simulate the minimum brightness threshold from the shader
                    const MIN_STAR_BRIGHTNESS = 0.3;

                    // If star is visible (brightness > 0.01), apply minimum threshold
                    let adjustedBrightness = starBrightness;
                    if (starBrightness > 0.01) {
                        adjustedBrightness = Math.max(starBrightness, MIN_STAR_BRIGHTNESS);

                        // Verify that adjusted brightness meets minimum threshold
                        expect(adjustedBrightness).toBeGreaterThanOrEqual(MIN_STAR_BRIGHTNESS);
                    }

                    // Verify brightness is in valid range
                    expect(adjustedBrightness).toBeGreaterThanOrEqual(0);
                    expect(adjustedBrightness).toBeLessThanOrEqual(1);
                }
            ),
            { numRuns: 100 }
        );
    });

    /**
     * Feature: blackhole-enhancement, Property 30: Tone mapping preserves hue
     * Validates: Requirements 9.5
     * 
     * For any color input to the tone mapping function, the output color should
     * have the same hue (in HSL color space) while brightness is adjusted.
     */
    it('Property 30: Tone mapping preserves hue', () => {
        fc.assert(
            fc.property(
                fc.record({
                    r: fc.float({ min: Math.fround(0), max: Math.fround(1) }).filter(x => !isNaN(x) && isFinite(x)),
                    g: fc.float({ min: Math.fround(0), max: Math.fround(1) }).filter(x => !isNaN(x) && isFinite(x)),
                    b: fc.float({ min: Math.fround(0), max: Math.fround(1) }).filter(x => !isNaN(x) && isFinite(x)),
                    exposure: fc.float({ min: Math.fround(0.1), max: Math.fround(3.0) }).filter(x => !isNaN(x) && isFinite(x) && x > 0)
                }).filter(({ r, g, b }) => {
                    // Filter out colors that are too dark or have undefined hue
                    const max = Math.max(r, g, b);
                    const min = Math.min(r, g, b);
                    return max > 0.1 && (max - min) > 0.05;
                }),
                ({ r, g, b, exposure }) => {
                    // Get original hue
                    const [originalHue, originalSat, originalLight] = rgbToHsl(
                        Math.round(r * 255),
                        Math.round(g * 255),
                        Math.round(b * 255)
                    );

                    // Apply tone mapping
                    const [toneMappedR, toneMappedG, toneMappedB] = toneMapPreserveHue(r, g, b, exposure);

                    // Get tone mapped hue
                    const [toneMappedHue, toneMappedSat, toneMappedLight] = rgbToHsl(
                        Math.round(toneMappedR * 255),
                        Math.round(toneMappedG * 255),
                        Math.round(toneMappedB * 255)
                    );

                    // Verify hue is preserved (within tolerance for floating point errors)
                    // Hue wraps around at 360, so we need to handle that
                    const hueDiff = Math.abs(originalHue - toneMappedHue);
                    const normalizedHueDiff = Math.min(hueDiff, 360 - hueDiff);

                    // Allow 5 degree tolerance for hue preservation
                    expect(normalizedHueDiff).toBeLessThan(5);

                    // Verify output is in valid range
                    expect(toneMappedR).toBeGreaterThanOrEqual(0);
                    expect(toneMappedR).toBeLessThanOrEqual(1);
                    expect(toneMappedG).toBeGreaterThanOrEqual(0);
                    expect(toneMappedG).toBeLessThanOrEqual(1);
                    expect(toneMappedB).toBeGreaterThanOrEqual(0);
                    expect(toneMappedB).toBeLessThanOrEqual(1);
                }
            ),
            { numRuns: 100 }
        );
    });

    /**
     * Feature: blackhole-enhancement, Property 31: UI contrast ratio compliance
     * Validates: Requirements 9.6
     * 
     * For any UI text and background color combination, the contrast ratio should
     * meet or exceed 4.5:1 (WCAG AA standard).
     */
    it('Property 31: UI contrast ratio compliance', () => {
        // Test common UI color combinations used in the application
        const uiColorCombinations: Array<{
            name: string;
            foreground: [number, number, number];
            background: [number, number, number];
        }> = [
                { name: 'White text on black background', foreground: [255, 255, 255], background: [0, 0, 0] },
                { name: 'White text on dark gray', foreground: [255, 255, 255], background: [26, 26, 26] },
                { name: 'Cyan text on black', foreground: [0, 255, 255], background: [0, 0, 0] },
                { name: 'Light gray text on black', foreground: [156, 163, 175], background: [0, 0, 0] },
                { name: 'Yellow text on black', foreground: [250, 204, 21], background: [0, 0, 0] },
            ];

        uiColorCombinations.forEach(({ name, foreground, background }) => {
            const contrastRatio = getContrastRatio(foreground, background);
            const meetsAA = meetsWCAGAA(foreground, background);

            // Verify contrast ratio is at least 4.5:1 for WCAG AA
            expect(contrastRatio, `${name} should meet WCAG AA (4.5:1)`).toBeGreaterThanOrEqual(4.5);
            expect(meetsAA, `${name} should pass WCAG AA check`).toBe(true);
        });
    });

    /**
     * Additional test: RGB to HSL and back should be a round trip
     */
    it('RGB to HSL round trip', () => {
        fc.assert(
            fc.property(
                fc.record({
                    r: fc.integer({ min: 0, max: 255 }),
                    g: fc.integer({ min: 0, max: 255 }),
                    b: fc.integer({ min: 0, max: 255 })
                }),
                ({ r, g, b }) => {
                    const [h, s, l] = rgbToHsl(r, g, b);
                    const [r2, g2, b2] = hslToRgb(h, s, l);

                    // Allow small rounding errors (Â±1)
                    expect(Math.abs(r - r2)).toBeLessThanOrEqual(1);
                    expect(Math.abs(g - g2)).toBeLessThanOrEqual(1);
                    expect(Math.abs(b - b2)).toBeLessThanOrEqual(1);
                }
            ),
            { numRuns: 100 }
        );
    });
});
